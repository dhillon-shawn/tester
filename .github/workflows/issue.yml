name: Create branch and PR for issues

on:
  issues:
    types: [opened]

permissions:
  contents: write
  pull-requests: write
  issues: write

concurrency:
  group: issues
  cancel-in-progress: true

jobs:
  parse:
    outputs:
      start:         ${{ steps.parse.outputs.start }}
      end:           ${{ steps.parse.outputs.end }}
      effort:        ${{ steps.parse.outputs.effort }}
      why:           ${{ steps.parse.outputs.why }}
      plan:          ${{ steps.parse.outputs.plan }}
      risk:          ${{ steps.parse.outputs.risk }}
      groups:        ${{ steps.parse.outputs.groups }}
      emails:        ${{ steps.parse.outputs.emails }}
      notified_when: ${{ steps.parse.outputs.notified_when }}
      notified_how:  ${{ steps.parse.outputs.notified_how }}
      backup:        ${{ steps.parse.outputs.backup }}
      public:        ${{ steps.parse.outputs.public }}
      cdt:           ${{ steps.parse.outputs.cdt }}
      new_app:       ${{ steps.parse.outputs.new_app }}
      title:         ${{ steps.parse.outputs.title }}
      url:           ${{ steps.parse.outputs.url }}
    if: >
      contains(join(github.event.issue.labels.*.name, ','), 'release') ||
      contains(join(github.event.issue.labels.*.name, ','), 'hotfix')
    runs-on: ubuntu-latest

    steps:
      - name: assign check
        id: check
        run: |
          echo "issue_number=${{ github.event.issue.number }}"
          echo "assignees_json=${{ toJson(github.event.issue.assignees) }}"
          if [ "${{ toJson(github.event.issue.assignees) }}" = "[]" ]; then
            echo "has_assignees=false" >> $GITHUB_OUTPUT
            echo "result=no current assignee"
          else
            echo "has_assignees=true" >> $GITHUB_OUTPUT
            echo "result=already assigned"
          fi

      - name: assign ensure
        if: steps.check.outputs.has_assignees == 'false'
        uses: pozil/auto-assign-issue@v2
        with:
          assignees: "${{ github.event.issue.user.login }}"
          numOfAssignee: 1

      - name: issue refresh
        id: issue
        uses: actions/github-script@v7
        with:
          script: |
            const repo = context.repo;
            const num = context.payload.issue.number;
            const { data: issue } = await github.rest.issues.get({ ...repo, issue_number: num });
            const labels = (issue.labels || []).map(l => typeof l === 'string' ? l : l.name);
            const mode = labels.includes('hotfix') ? 'hotfix' : 'release';
            core.info(`issue: #${num} | mode=${mode} | labels=[${labels.join(', ')}] | assignees=[${(issue.assignees||[]).map(a=>a.login).join(', ')}]`);
            core.setOutput('title', issue.title || '');
            core.setOutput('body', issue.body || '');
            core.setOutput('labels', JSON.stringify(labels));
            core.setOutput('assignees', JSON.stringify((issue.assignees || []).map(a => a.login)));
            core.setOutput('milestone', issue.milestone ? String(issue.milestone.number) : '');
            core.setOutput('mode', mode);

      - name: meta derive
        id: meta
        uses: actions/github-script@v7
        with:
          script: |
            const issueNum = context.payload.issue.number;
            const nextPrNumber = issueNum + 1;
            const defaultBranch = context.payload.repository.default_branch;
            const mode = '${{ steps.issue.outputs.mode }}';
            const rawTitle = ${{ toJson(steps.issue.outputs.title) }};
            const title = rawTitle || mode;
            const slug = title.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'').slice(0,50) || mode;
            const branch = `${mode}/${nextPrNumber}-${slug}`;
            const isDraft = mode === 'release';
            const prefix = isDraft ? 'Release: ' : 'Hotfix: ';
            core.info(`meta: issue=${issueNum} -> planned_pr=${nextPrNumber} | mode=${mode} | draft=${isDraft} | branch=${branch} | default=${defaultBranch}`);
            core.setOutput('default', defaultBranch);
            core.setOutput('branch', branch);
            core.setOutput('plannedPr', String(nextPrNumber));
            core.setOutput('isDraft', String(isDraft));
            core.setOutput('prefix', prefix);
            core.setOutput('slug', slug);

      - name: checkout default
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.meta.outputs.default }}

      - name: branch init
        env:
          BRANCH: ${{ steps.meta.outputs.branch }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          MODE: ${{ steps.issue.outputs.mode }}
        run: |
          echo "creating branch=$BRANCH from default=${{ steps.meta.outputs.default }} for issue #$ISSUE_NUMBER mode=$MODE"
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git switch -c "$BRANCH"
          git commit --allow-empty -m "chore: init $MODE branch for #$ISSUE_NUMBER [skip ci]"
          git push --set-upstream origin "$BRANCH"
          echo "pushed branch=$BRANCH"

      - name: pr open
        id: createpr
        uses: actions/github-script@v7
        with:
          script: |
            const repo = context.repo;
            const issue_number = context.payload.issue.number;
            const base = '${{ steps.meta.outputs.default }}';
            const head = '${{ steps.meta.outputs.branch }}';
            const isDraft = '${{ steps.meta.outputs.isDraft }}' === 'true';
            const title = '${{ steps.meta.outputs.prefix }}' + ${{ toJson(steps.issue.outputs.title) }};
            const body = [
              `${isDraft ? 'Draft PR' : 'PR'} for issue #${issue_number}`,
              '',
              `Closes #${issue_number}`,
              '',
              '---',
              ${{ toJson(steps.issue.outputs.body) }}
            ].join('\n');
            const { data: pr } = await github.rest.pulls.create({ ...repo, title, head, base, body, draft: isDraft });
            const labels = JSON.parse('${{ steps.issue.outputs.labels }}');
            if (labels.length) await github.rest.issues.addLabels({ ...repo, issue_number: pr.number, labels });
            const milestone = '${{ steps.issue.outputs.milestone }}';
            if (milestone) await github.rest.issues.update({ ...repo, issue_number: pr.number, milestone: Number(milestone) });
            const assignees = JSON.parse('${{ steps.issue.outputs.assignees }}');
            const finalAssignees = assignees.length ? assignees : ['${{ github.event.issue.user.login }}'];
            await github.rest.issues.addAssignees({ ...repo, issue_number: pr.number, assignees: finalAssignees });
            core.info(`pr: actual=${pr.number} | planned=${'${{ steps.meta.outputs.plannedPr }}'} | url=${pr.html_url} | head=${head} -> base=${base} | draft=${isDraft}`);
            core.setOutput('pr_number', String(pr.number));
            core.setOutput('pr_url', pr.html_url)

      - name: pr verify
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const planned = Number('${{ steps.meta.outputs.plannedPr }}');
            const actual  = Number('${{ steps.createpr.outputs.pr_number }}');
            if (planned !== actual) {
              core.warning(`verify: planned_pr=${planned} != actual_pr=${actual} (branch remains '${{ steps.meta.outputs.branch }}')`);
            } else {
              core.info(`verify: planned_pr matches actual_pr=${actual}`);
            }

      - name: Comment PR link on the issue (optional)
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              ...context.repo,
              issue_number: context.payload.issue.number,
              body: `Opened ${'${{ steps.issue.outputs.mode }}' === 'feature' ? 'draft ' : ''}PR: ${{ steps.createpr.outputs.pr_url }}\nBranch: \`${{ steps.meta.outputs.branch }}\``
            })
              
            
      - name: Parse issue → simple outputs (robust checkboxes)
        id: parse
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            if (!issue) { core.setFailed('No issue payload.'); return; }
            const body = '\n' + (issue.body || '') + '\n';
            const esc = s => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

            function block(label) {
              const re = new RegExp(
                `\\n\\s*#{1,6}\\s*${esc(label)}\\s*\\n([\\s\\S]*?)(?=\\n\\s*#{1,6}\\s*|$)`,
                'i'
              );
              const m = body.match(re);
              return (m ? m[1].trim() : '');
            }
            function line(label) {
              return block(label).split('\n').map(s => s.trim()).filter(Boolean)[0] || '';
            }

            // ---------- Robust checkbox parsing ----------
            const normalize = (s) =>
              s.toLowerCase()
              .replace(/\(.*?\)/g, ' ')     // drop parenthetical notes
              .replace(/[^a-z0-9\s]/g, ' ') // strip punctuation
              .replace(/\s+/g, ' ')         // collapse whitespace
              .trim();

            const cbBlock = block('Confirmations');
            const cbLines = cbBlock.split('\n').map(l => l.trim());

            // Collect found checkboxes from the body
            const found = {}; // normLabel -> 'Yes'/'No'
            for (const l of cbLines) {
              const m = l.match(/^[*-]\s*\[( |x|X)\]\s*(.+?)\s*$/);
              if (!m) continue;
              const checked = (m[1].toLowerCase() === 'x');
              const labelNorm = normalize(m[2]);
              found[labelNorm] = checked ? 'Yes' : 'No';
            }

            // Targets we care about (normalized)
            const targets = {
              public:  'impacts the public',
              cdt:     'involves cdt',
              new_app: 'new app esd needs to know'
            };

            // Default to 'No' and fill from found (supports minor text changes)
            const pickByIncludes = (needle) => {
              for (const k of Object.keys(found)) {
                if (k === needle || k.includes(needle)) return found[k];
              }
              return 'No';
            };

            const publicYN  = pickByIncludes(targets.public);
            const cdtYN     = pickByIncludes(targets.cdt);
            const newAppYN  = pickByIncludes(targets.new_app);

            // ---------- Other fields ----------
            const out = {
              start:         line('Start date'),
              end:           line('End date'),
              effort:        line('Effort/Project'),
              why:           block('Justification'),
              plan:          block('Implementation plan'),
              risk:          block('Risk'),
              groups:        line('Impacted groups'),
              emails:        line('Impacted users (emails)'),
              notified_when: line('When were impacted users last notified?'),
              notified_how:  line('How were impacted users last notified?'),
              backup:        line('Backup contact (email)'),
              public:        publicYN,
              cdt:           cdtYN,
              new_app:       newAppYN,
              issue:         String(issue.number),
              title:         issue.title || '',
              url:           issue.html_url || ''
            };

            Object.entries(out).forEach(([k,v]) => core.setOutput(k, v ?? ''));
              
              

  use-values:
    needs: parse
    if: needs.parse.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Demo simple outputs
        run: |
          echo "Window: ${{ needs.parse.outputs.start }} → ${{ needs.parse.outputs.end }}"
          echo "Effort: ${{ needs.parse.outputs.effort }}"
          echo "Public: ${{ needs.parse.outputs.public }}, CDT: ${{ needs.parse.outputs.cdt }}, New app: ${{ needs.parse.outputs.new_app }}"
          echo "Groups: ${{ needs.parse.outputs.groups }}"
          echo "Notified: ${{ needs.parse.outputs.notified_when }} via ${{ needs.parse.outputs.notified_how }}"
          echo "Backup: ${{ needs.parse.outputs.backup }}"
          echo "Issue: ${{ needs.parse.outputs.title }}"
          echo "URL: ${{ needs.parse.outputs.url }}"
          printf "\nWHY:\n%s\n"  "${{ needs.parse.outputs.why }}"
          printf "\nPLAN:\n%s\n" "${{ needs.parse.outputs.plan }}"
          printf "\nRISK:\n%s\n" "${{ needs.parse.outputs.risk }}"           
              
              
              
              