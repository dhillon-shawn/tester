name: issue-reopen-get-rc-version

on:
  issues:
    types: [reopened]

permissions:
  contents: read    # to read releases and repo contents
  issues: read      # to read the issue event (implicit)

jobs:
  fetch-rc-version:
    runs-on: ubuntu-latest
    env:
      RC_META_PATH: rc-meta.json   # change if your file lives elsewhere in the tag/release
      GH_TOKEN: ${{ github.token }}
    outputs:
      version: ${{ steps.extract.outputs.version }}
      rc_name: ${{ steps.find_pr.outputs.rc_name }}
      pr_number: ${{ steps.find_pr.outputs.pr_number }}

    steps:
    - name: Find merged PR that closed this issue â†’ rc tag (REST)
      id: find-pr
      env:
        ISSUE_NUMBER: ${{ github.event.issue.number }}
      shell: bash
      run: |
        set -euo pipefail

        owner="${GITHUB_REPOSITORY%/*}"
        repo="${GITHUB_REPOSITORY#*/}"
        issue="$ISSUE_NUMBER"

        # 1) Get all timeline events and pull out cross-references that "will close" this issue
        #    then extract candidate PR numbers
        candidates=$(gh api \
          "repos/$owner/$repo/issues/$issue/timeline" \
          --paginate \
          --jq '
            map(select(.event=="cross-referenced"
                      and .will_close_target==true
                      and .source.type=="issue"
                      and (.source.issue.pull_request|type)=="object"))
            | map(.source.issue.number)
            | unique
            | .[]')

        if [[ -z "${candidates:-}" ]]; then
          echo "No cross-referenced PRs that would close issue #$issue" >&2
          exit 1
        fi

        # 2) Keep only merged PRs, pick the most recent by merged_at
        best_pr=""
        best_merged_at=""
        for n in $candidates; do
          # query PR once and parse merged + merged_at
          read -r merged merged_at < <(gh api "repos/$owner/$repo/pulls/$n" --jq '.merged, .merged_at')
          if [[ "$merged" == "true" ]]; then
            if [[ -z "$best_merged_at" || "$merged_at" > "$best_merged_at" ]]; then
              best_pr="$n"
              best_merged_at="$merged_at"
            fi
          fi
        done

        if [[ -z "${best_pr:-}" ]]; then
          echo "No merged PR found among cross-references for issue #$issue" >&2
          exit 1
        fi

        rc_tag="rc-pr-${best_pr}"

        echo "pr_number=$best_pr"  >> "$GITHUB_OUTPUT"
        echo "rc_tag=$rc_tag"      >> "$GITHUB_OUTPUT"

    - name: Download rc-meta.json (release asset or tag) and extract version
      id: get-meta
      env:
        RC_META_PATH: rc-meta.json
      shell: bash
      run: |
        set -euo pipefail

        owner="${GITHUB_REPOSITORY%/*}"
        repo="${GITHUB_REPOSITORY#*/}"
        rc_tag="${{ steps.find-pr.outputs.rc_tag }}"
        meta_path="$RC_META_PATH"

        mkdir -p meta
        target="meta/$(basename "$meta_path")"

        if gh release view "$rc_tag" >/dev/null 2>&1; then
          gh release download "$rc_tag" -p "$(basename "$meta_path")" -D meta >/dev/null 2>&1 \
            || gh api "repos/$owner/$repo/contents/$meta_path?ref=$rc_tag" --jq '.content' | base64 -d > "$target"
        else
          gh api "repos/$owner/$repo/contents/$meta_path?ref=$rc_tag" --jq '.content' | base64 -d > "$target"
        fi

        [[ -s "$target" ]] || { echo "rc-meta.json missing at $meta_path in $rc_tag"; exit 1; }

        version=$(jq -r '.version // .Version // .VERSION // empty' "$target")
        [[ -n "$version" && "$version" != "null" ]] || { echo "No version key in $target"; exit 1; }

        echo "version=$version" >> "$GITHUB_OUTPUT"
        echo "RC: $rc_tag"
        echo "Version: $version"
