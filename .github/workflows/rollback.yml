name: rollback on issue reopen
on:
  issues:
    types: [reopened]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  rollback:
    if: >
      !contains(toJson(github.event.issue), '"pull_request"') &&
      (contains(join(github.event.issue.labels.*.name, ','), 'release') ||
       contains(join(github.event.issue.labels.*.name, ','), 'hotfix'))
    runs-on: ubuntu-latest

    steps:
      - name: resolve merged PR
        id: find
        uses: actions/github-script@v7
        with:
          script: |
            const repo = context.repo;
            const n = context.payload.issue.number;
            const q = `repo:${repo.owner}/${repo.repo} is:pr is:merged in:body "Closes #${n}"`;
            const s = await github.rest.search.issuesAndPullRequests({ q, per_page: 1, sort: 'updated', order: 'desc' });
            if (!s.data.items.length) core.setFailed(`no merged PR found for #${n}`);
            const prNum = s.data.items[0].number;
            const pr = (await github.rest.pulls.get({ ...repo, pull_number: prNum })).data;
            if (!pr.merged) core.setFailed(`PR #${prNum} not merged`);
            // optional: read rc-meta.json for logging
            try {
              const rel = await github.request('GET /repos/{owner}/{repo}/releases/tags/{tag}', {
                owner: repo.owner, repo: repo.repo, tag: `rc-pr-${pr.number}`
              });
              const asset = (rel.data.assets || []).find(a => a.name === 'rc-meta.json');
              if (asset) {
                const bin = await github.request('GET ' + asset.url, { headers: { Accept: 'application/octet-stream' } });
                const meta = JSON.parse(Buffer.from(bin.data).toString('utf8'));
                core.info(`rc-meta: version=${meta.version || ''} commit=${meta.commit || ''}`);
              }
            } catch {}
            core.setOutput('pr_node_id', pr.node_id);
            core.setOutput('pr_number', String(pr.number));
            core.setOutput('base_ref', pr.base.ref);
            core.setOutput('head_sha', pr.head.sha || '');
            core.setOutput('head_ref', pr.head.ref || '');
            core.setOutput('title', pr.title || '');

      - name: open revert PR (GraphQL)
        id: revert
        uses: actions/github-script@v7
        with:
          script: |
            const prId = '${{ steps.find.outputs.pr_node_id }}';
            const m = `mutation($input: RevertPullRequestInput!){
              revertPullRequest(input:$input){ pullRequest{ number url mergeable state } } }`;
            const r = await github.graphql(m, { input: { pullRequestId: prId }});
            const rp = r?.revertPullRequest?.pullRequest;
            if (!rp) core.setFailed('revertPullRequest failed');
            core.info(`revert PR opened: #${rp.number} ${rp.url} state=${rp.state} mergeable=${rp.mergeable}`);
            core.setOutput('number', String(rp.number));

      - name: merge revert PR immediately  # requires “Allow specified actors to bypass required pull requests”
        uses: actions/github-script@v7
        with:
          script: |
            const repo = context.repo;
            const num = Number('${{ steps.revert.outputs.number }}');
            // choose your merge method; squash is typical for revert PRs
            await github.rest.pulls.merge({ ...repo, pull_number: num, merge_method: 'squash' });
            core.info(`revert PR #${num} merged`)

      - name: create hotfix branch at original head and open PR
        uses: actions/github-script@v7
        with:
          script: |
            const repo = context.repo;
            const prNum = Number('${{ steps.find.outputs.pr_number }}');
            const headSha = '${{ steps.find.outputs.head_sha }}';
            const title = '${{ steps.find.outputs.title }}' || `pr-${prNum}`;
            const slug = title.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'').slice(0,50) || `pr-${prNum}`;
            const newRef = `refs/heads/hotfix/${prNum}-${slug}`;
            if (!headSha) { core.info('no head sha; skip'); return; }
            // create branch
            await github.rest.git.createRef({ ...repo, ref: newRef, sha: headSha }).catch(e => {
              if (e.status !== 422) throw e; // already exists is fine
            });
            // open PR back to default
            const base = '${{ steps.find.outputs.base_ref }}';
            const head = `hotfix/${prNum}-${slug}`;
            const { data: pr } = await github.rest.pulls.create({
              ...repo, title: `fix: follow-up for PR #${prNum}`, head, base, body: `Continuation branch from original head of PR #${prNum}.`
            });
            core.info(`hotfix PR opened: #${pr.number} ${pr.html_url}`)
